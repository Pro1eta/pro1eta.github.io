<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" >

<title>C++ primer(fifth edition)札记-1</title>
<meta name="keywords" content="C++ primer(fifth edition)札记-1, Proleta&#39;s blog">
<meta name="description" content="第2章 变量与基本类型, 第3章 字符,串向量和数组">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="C++ primer(fifth edition)札记-1">
<meta property="og:description" content="第2章 变量与基本类型, 第3章 字符,串向量和数组">

<link rel="shortcut icon" href="/images/avatar.png">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://pro1eta.github.io">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://pro1eta.github.io">
        <h1 class="site-title">Proleta&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="https://pro1eta.github.io/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">C++ primer(fifth edition)札记-1</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-06-24</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/C-C/">
              C/C++
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="第2章-变量和基本类型">第2章 变量和基本类型</h1>
<h2 id="基本内置类型">2.1 基本内置类型</h2>
<p>包括算术类型(arithmetic type)和空类型(void).
前者包括整型(包括字符与布尔值)和浮点型.</p>
<h3 id="类型转换convert">2.1.2 类型转换(convert)</h3>
<ul>
<li>将非布尔类型的算术值赋值给布尔类型时, 初始值为 0 结果为 false,
否则结果都是 true.</li>
<li>将布尔值赋值给非布尔类型时, 初始值为 false 结果为 0. 初始值为 true
结果为 1.</li>
<li>把一个浮点数赋值给整数类型时进行近似处理,
结果仅保留浮点数中小数点以前的部分.</li>
<li>把一个整数值赋值给浮点类型的时候, 小数部分记为 0.
如果该整数所占的空间超过浮点类型的容量, 精度可能有损失.</li>
<li>赋给无符号类型一个超出其表示范围的值时,
结果是初始值对无符号类型表示数值总数取模后的余数. 例如, size 为 8 bit
大小的 unsigned char , 赋值为 -1, 所得的结果是 255.</li>
<li>赋值给一个带符号类型一个超出其表示范围的值时, 结果是未定义的.</li>
</ul>
<h3 id="字面值常量">2.1.3 字面值常量</h3>
<ul>
<li><p>指定字面值类型</p>
<table>
<thead>
<tr class="header">
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr class="even">
<td>u8</td>
<td>UTF-8</td>
<td>char</td>
</tr>
<tr class="odd">
<td>u</td>
<td>Unicode 16</td>
<td>char16_t</td>
</tr>
<tr class="even">
<td>U</td>
<td>Unicode 32</td>
<td>char32_t</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>后缀</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>U or u</td>
<td>unsigned</td>
</tr>
<tr class="even">
<td>l or L</td>
<td>long</td>
</tr>
<tr class="odd">
<td>ll or LL</td>
<td>long long</td>
</tr>
<tr class="even">
<td>f or F</td>
<td>float</td>
</tr>
<tr class="odd">
<td>l or L</td>
<td>long double</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="变量">2.2 变量</h2>
<ul>
<li><p>列表初始化(list initialization), 形如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> units_sold = {<span class="number">0</span>};</span><br><span class="line"><span class="type">int</span> units_sold{<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>都是<strong>列表初始化</strong>.</p></li>
<li><p>默认初始化</p>
<p>如果定义变量的时候没有指定初值,
则变量被<strong>默认初始化</strong>(default initialized).
<strong>内置类型</strong>的变量未被显示初始化,
定义于任何函数体之外的变量被初始化为0.
定义在函数体内部的值<strong>不被初始化</strong>(uninitialized),
未被初始化的内置类型变量的值是<strong>未定义的</strong>.</p>
<p>是否允许不经初始化就定义对象, 以及初始化对象的方式由每个类各自决定.
如果前者被允许, 它将决定对象的初始值.</p>
<p>绝大多数类都支持无需显式初始化而定义对象.</p></li>
</ul>
<h3 id="变量声明与定义的关系">2.2.2 变量声明与定义的关系</h3>
<p>如果想要声明一个变量而非定义它, 就在前面加上关键字 extern,
并且不要显示地初始化它. 变量只能定义一次, 可被多次声明. 试图初始化由
extern 标记的变量将会引发错误.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;	<span class="comment">// 声明而非定义 i</span></span><br></pre></td></tr></table></figure>
<h3 id="标识符">2.2.3 标识符</h3>
<p>标识符(identifier)最好不要以下划线开头.</p>
<h2 id="复合类型compound-type">2.3 复合类型(compound type)</h2>
<ul>
<li><strong>引用(reference)</strong>即别名,
只是为一个已经存在的对象起另外的名字. 引用必须被初始化. 每个引用标识符用
&amp; 开头.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br></pre></td></tr></table></figure>
<p>引用本身不是一个对象, 不能定义引用的引用.
引用不能绑定在字面值或者某个表达式的计算结果.</p>
<p>但是, 常量引用是可以绑定非常量的(参加下文的顶层 const).</p>
<p>另外, 在初始化常量引用的时候, 允许用任意表达式作为初始值,
只要该表达式能转化成引用的类型即可. 但对一般的引用而言,
这是非法的行为.</p>
<h3 id="指针">2.3.2 指针</h3>
<p>指针在块作用域定义时没有初始化, 将拥有不确定的值.
<strong>任何非0指针对应布尔值均是true</strong>.</p>
<p>指针的值(地址)应属于以下4种状态:</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一位置. 访问它的后果是未定义的.</li>
<li>空指针, 即没有指向任何对象. 访问它的后果是未定义的.</li>
<li>无效指针, 即不属于上述情况. 访问它的后果是未定义的.</li>
</ul>
<p>生成空指针可以:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// #include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>但是不能直接把为0的int类型变量赋值给指针. 简易初始化所有的指针.</p>
<ul>
<li><p>void* 指针</p>
<p>特殊的指针类型, 可以存放任意对象的地址.不能直接操作 void*
指针指向的对象, 因为我们并不知道这个对象到底什么类型,
也就无法确定这个对象上能做哪些操作.</p></li>
</ul>
<h3 id="理解复合类型的声明">2.3.3 理解复合类型的声明</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1, p2;</span><br></pre></td></tr></table></figure>
<p>其含义是 p1 是指针, p2 是 int型的值.</p>
<p>引用不是一个对象, 定义指向引用的指针是错误的.
但是可以存在对指针的引用.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p;</span><br><span class="line"></span><br><span class="line">r = &amp;i;	<span class="comment">// 实际上改变了指针p的值</span></span><br><span class="line">*r = <span class="number">0</span>;	<span class="comment">// 解引用r实际上就是解引用p, 最终改变了i的值</span></span><br></pre></td></tr></table></figure>
<h2 id="const-限定符">2.4 const 限定符</h2>
<p>const 必须初始化.</p>
<p>默认状态下, const 对象仅在定义过文件中有效,
原因是编译器将在编译过程中把用到该变量的地方都替换成对应的值.</p>
<p>如果在多文件程序中, 只想定义一次, 在多个文件中共享 const 对象.
做法是在const前添加extern关键字. 在声明和定义前都加上.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></figure>
<h3 id="const-的引用">2.4.1 const 的引用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;	<span class="comment">// right</span></span><br><span class="line">r1 = <span class="number">42</span>				<span class="comment">// wrong</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;		<span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化和对-const-的引用">初始化和对 const 的引用</h4>
<h3 id="指针与-const">2.4.2 指针与 const</h3>
<p>指针的类型必须与所指的对象一致,
但是<strong>指向常量的指针</strong>可以指向非常量对象，其含义是<strong>不能通过该指针改变对象的值</strong>,
但可以通过其它途径改变. 另外, 该指针也可以指向其它常量对象,
等于说具有相同的底层const 资格.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;dval;	<span class="comment">// right</span></span><br></pre></td></tr></table></figure>
<p>同时也有<strong>常量指针(const pointer)</strong>, 形如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;</span><br></pre></td></tr></table></figure>
<p>其含义是指针本身是一个常量, 不能改变其存储的地址.
但是指针指向的值是否能改变取决于那个值的类型本身.</p>
<h3 id="顶层-const">2.4.3 顶层 const</h3>
<p>用名词顶层 const(top-level const) 表示指针本身是一个常量,
而用名词底层 const(low-level const) 表示指针所指的对象是一个常量.</p>
<p>一般地, 顶层 const 表示任意的对象是常量, 底层 const
与复合类型的基本类型部分有关.</p>
<p>指针既可以是顶层 const, 也可以是底层 const.</p>
<p>顶层 const 遵循赋值的一般规则就可以了. 一旦赋值涉及到指针和引用,
就容易让人混乱, 遵循以下的规则可以避免出错.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;		 	</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;  		<span class="comment">// 不能改变 p1, 顶层 cosnt </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>	 		<span class="comment">// 不能改变 ci, 顶层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci; 		<span class="comment">// 允许改变 p2, 不允许改变指向的值, 底层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;	<span class="comment">// 同时是顶层 const 和底层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;			<span class="comment">// 底层 const</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = p3;				<span class="comment">// wrong: p3包含底层const, p没有</span></span><br><span class="line">p2 = p3;					<span class="comment">// right: p2和p3都是底层const</span></span><br><span class="line">p2 = &amp;i;					<span class="comment">// right: int*能够转换成const int*</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci;				<span class="comment">// wrong: 普通的int&amp;不能绑定在 int 常量上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;			<span class="comment">// right: const int&amp; 可以绑定在普通的 int 上</span></span><br></pre></td></tr></table></figure>
<p>总结: 执行拷贝操作的时候, 拷入和拷出对象要么具有相同的底层 const
资格, 要么是将底层的非常量转化为常量, 反之则不行. 换言之, 底层 const
总是在赋值的左边.</p>
<h3 id="constexpr-与常量表达式">2.4.4 constexpr 与常量表达式</h3>
<p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式.
比如说字面值. 一般来说, 如果认定某个变量是常量表达式, 那么就把他声明为
constexpr.</p>
<h2 id="处理类型">2.5 处理类型</h2>
<h3 id="类型别名">2.5.1 类型别名</h3>
<p>传统方法是使用typedef</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages		<span class="comment">// wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;		<span class="comment">// base 是 double 的同义词, p 是 double* 的同义词</span></span><br></pre></td></tr></table></figure>
<p>C++11提供了别名声明的方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;</span><br></pre></td></tr></table></figure>
<h4 id="指针-常量和类型别名">指针, 常量和类型别名</h4>
<p>类型别名若是复合类型或常量,
把它用到声明语句中会产生意料之外的后果.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr is a constant pointer to char</span></span><br><span class="line"><span class="type">const</span> pstring *ps; <span class="comment">// ps is a pointer to a constant pointer to char</span></span><br></pre></td></tr></table></figure>
<p>此时并不能够将第2行理解成: cstr 是指向常量char的指针.
const是对给定类型的修饰, 既然pstring是指向char类型的指针, 那么const
pstring就是指向char类型的指针常量.</p>
<h3 id="auto">2.5.2 auto</h3>
<p>auto会让编译器替我们分析表达式所属的类型. 一般来说 auto
会忽略掉顶层const, 保留底层const. 如果希望推断出的auto类型是顶层const,
需要手动指出:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;</span><br></pre></td></tr></table></figure>
<p>auto只确定了基本的数据类型, 定义多个变量时, 要注意一致性.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p2 = &amp;ci;		<span class="comment">// 错误: i的类型是int, 但是ci的类型是const int</span></span><br></pre></td></tr></table></figure>
<h3 id="decltype-类型指示符c11">2.5.3 decltype 类型指示符(C++11)</h3>
<p>如果 decltype 使用的表达式是一个变量, 则decltype
返回该变量的类型(保留顶层 const); 如果 decltype
使用的表达式不是一个变量, 则 decltype 返回结果对应的类型. decltype
的结果可以是一个引用类型.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;		<span class="comment">// x 的类型是 const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;		<span class="comment">// y 的类型是 const int&amp;, 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;			<span class="comment">// 错误, z是一个引用, 必须初始化</span></span><br></pre></td></tr></table></figure>
<p>如果表达式的内容是解引用操作, 得到引用类型.
如果是双层括号(这样编译器会认为这是一个表达式),
得到的结果永远是引用.</p>
<h2 id="自定义数据结构">2.6 自定义数据结构</h2>
<p>大致是C语言中的结构体, 故略过.</p>
<p>形如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> { <span class="comment">/* ... */</span> } accum, trans, *salesptr;</span><br><span class="line"><span class="comment">// equivalent, but better way to define these objects</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> { <span class="comment">/* ... */</span> };</span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>
<h3 id="预处理器概述">预处理器概述</h3>
<p>C++程序还会用到的预处理功能是<strong>头文件保护符(header
guard)</strong>. #define 指令把一个名字设定为预处理变量,
另外两个指令则分别检查某个指定的预处理变量是否已经定义: #ifdef
当且仅当变量已经定义时为真, #ifndef 当且仅当变量未定义时为真.
一旦检查结果为真, 则执行后续操作直到遇到 #endif 指令为止.形如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> {</span><br><span class="line"> std::string bookNo; <span class="type">unsigned</span> units_sold = <span class="number">0</span>; <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>预处理变量无视作用域的规则.</li>
<li>习惯性加上保护符吧.</li>
</ul>
<h1 id="第3章-字符串向量和数组">第3章 字符串、向量和数组</h1>
<h2 id="命名空间的-using-声明">3.1 命名空间的 using 声明</h2>
<h2 id="标准库类型-string">3.2 标准库类型 string</h2>
<h3 id="定义和初始化-string-对象">3.2.1 定义和初始化 string 对象</h3>
<a class="simple-lightbox" href="/2024/cpp-primer/image-20240625163653996-1720682411541-1.png"><img src="/images/loading.svg" data-src="/2024/cpp-primer/image-20240625163653996-1720682411541-1.png" class="" title="image-20240625163653996" lazyload=""></a>
<p>特别注意, 默认初始化的时候, string s1
是<strong>一个空串</strong>.</p>
<h4 id="直接初始化和拷贝初始化">直接初始化和拷贝初始化</h4>
<p>若用等号(=)初始化一个变量实际执行的是拷贝初始化.
如果不用等号则是直接初始化.可以通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure>
<p>来显示地创建一个临时对象用于拷贝.</p>
<h3 id="string对象上的操作">3.2.2 string对象上的操作</h3>
<a class="simple-lightbox" href="/2024/cpp-primer/image-20240625164505768-1720682411541-2.png"><img src="/images/loading.svg" data-src="/2024/cpp-primer/image-20240625164505768-1720682411541-2.png" class="" title="image-20240625164505768" lazyload=""></a>
<h4 id="读写-string-对象">读写 string 对象</h4>
<p>string 对象会自动忽略开头的空白(即空格符, 换行符, 制表符等),
并从第一个真正的字符读起直到遇到下一处空白为止.</p>
<h4 id="读取未知数量的-string-对象">读取未知数量的 string 对象</h4>
<h4 id="使用-getline-读取整行">使用 getline 读取整行</h4>
<p>有时我们希望能够在最终得到的字符保留输入时的空白符, 这时应该用
getline 函数. getline 只要一遇到换行符就阶数读取操作并返回结果.</p>
<p>getline() 是一个函数, 参数是一个输入流和一个 string 对象.</p>
<p>getline也返回其流参数. getline 会读取换行符,
但是不会将那个换行符存储在 string 对象中.</p>
<h4 id="string-的-empty-和-size-操作">string 的 empty 和 size 操作</h4>
<h4 id="stringsize_type-类型">string::size_type 类型</h4>
<p>只要记住它是一个无符号整型数, 同时避免它与 int 类型进行比较.</p>
<h4 id="比较-string-对象">比较 string 对象</h4>
<p>字典顺序. 使用关系运算符号.</p>
<h4 id="为-string-对象赋值">为 string 对象赋值</h4>
<h4 id="两个-string-对象相加">两个 string 对象相加</h4>
<h4 id="字面值和-string-对象相加">字面值和 string 对象相加</h4>
<p>字面值和字面值的相加是不允许的. 由于历史原因, 也为了与 C 兼容,
C++的字符串字面值不是标准库类型 string 的对象.</p>
<h3 id="处理-string-对象中的字符">3.2.3 处理 string 对象中的字符</h3>
<a class="simple-lightbox" href="/2024/cpp-primer/image-20240627102555997.png"><img src="/images/loading.svg" data-src="/2024/cpp-primer/image-20240627102555997.png" class="" title="image-20240627102555997" lazyload=""></a>
<h2 id="标准库类型-vector">3.3 标准库类型 vector</h2>
<p>使用 vector 前, 假定已经有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>
<p>在一些比较老的编译器中, 如果vector的元素还是vector, 外层 vector
的右尖括号需要添加空格.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vectot&lt;vector&lt;<span class="type">int</span>&gt; &gt;</span><br></pre></td></tr></table></figure>
<h3 id="定义和初始化-vector-对象">3.3.1 定义和初始化 vector 对象</h3>
<a class="simple-lightbox" href="/2024/cpp-primer/image-20240704235828903.png"><img src="/images/loading.svg" data-src="/2024/cpp-primer/image-20240704235828903.png" class="" title="image-20240704235828903" lazyload=""></a>
<p>对于第一种默认初始化, 将会创建指定类型的空 vector.</p>
<p>C++11提供了列表初始化的办法. 形如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line">vector&lt;string&gt; art = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>};</span><br></pre></td></tr></table></figure>
<h4 id="列表初始值还是元素数量">列表初始值还是元素数量?</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v1 has ten elements with value 0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2{<span class="number">10</span>}; <span class="comment">// v2 has one element with value 10</span></span><br></pre></td></tr></table></figure>
<p>使用圆括号, 是<strong>构造</strong>对象,
则vector中有10个<strong>值初始化</strong>的对象; 使用花括号,
则是<strong>列表初始化(list initialize)</strong>, 列表中只有一个元素.
此处的语法比较灵活, 使用花括号的时候, 编译器会先尝试列表初始化.
若不能列表初始化, 编译器会尝试构造vector.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1{<span class="number">10</span>, <span class="string">"hi"</span>};</span><br><span class="line"><span class="comment">/* 正确, 有十个值为"hi"的元素 */</span></span><br><span class="line">vector&lt;string&gt; v2{<span class="number">10</span>};</span><br><span class="line"><span class="comment">/* 正确, 有十个默认值的元素 */</span></span><br></pre></td></tr></table></figure>
<h3 id="向-vector-对象中添加元素">3.3.2 向 vector 对象中添加元素</h3>
<p>即利用 vector 的成员函数 <strong>push_back</strong>(x). 不赘述.</p>
<p>使用 push_back 的编程假定是循环正确无误. 如果循环体内部包含向 vector
对象添加元素的语句, 则不能使用范围 for 循环.</p>
<h3 id="其它-vector-操作">3.3.3 其它 vector 操作</h3>
<a class="simple-lightbox" href="/2024/cpp-primer/image-20240705002416117.png"><img src="/images/loading.svg" data-src="/2024/cpp-primer/image-20240705002416117.png" class="" title="image-20240705002416117" lazyload=""></a>
<p>size 的返回值类型是由 vector 定义的 size_type 无符号类型. 例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vecto&lt;<span class="type">int</span>&gt;::size_type</span><br></pre></td></tr></table></figure>
<h2 id="迭代器介绍">3.4 迭代器介绍</h2>
<h3 id="使用迭代器">3.4.1 使用迭代器</h3>
<p>拥有迭代器的类型都拥有名为 <strong>begin</strong> 和
<strong>end</strong> 的成员, 现阶段理解为指针即可. end
成员返回的迭代器称为尾后（off-the-end iterator）迭代器,
它负责指向最后一个元素的后一位. 如果容器是空的, begin 和 end
返回同一个迭代器.</p>
<p>特别注意, 不允许解引用尾后迭代器.</p>
<h4 id="迭代器运算符">迭代器运算符</h4>
<a class="simple-lightbox" href="/2024/cpp-primer/image-20240705003307308.png"><img src="/images/loading.svg" data-src="/2024/cpp-primer/image-20240705003307308.png" class="" title="image-20240705003307308" lazyload=""></a>
<h4 id="迭代器的类型">迭代器的类型</h4>
<p>拥有迭代器的标准库类型使用 <strong>iterator</strong> 和
<strong>const_iterator</strong> 来表示迭代器的类型. 形如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">// it 的类型是迭代器 vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure>
<p><strong>iterator</strong> 可读可写. <strong>const_iterator</strong>
可读但是不可通过迭代器修改指向的元素(不能通过解引用修改).</p>
<p>如果对象是常量, begin 和 end 返回 const_iterator; 若不是, 则返回
iterator;</p>
<p>对于无需写操作的时候, 可以使用 cbegin 和 cend, 它们只返回
const_iterator 类型.</p>
<h3 id="迭代器运算">3.4.2 迭代器运算</h3>
<a class="simple-lightbox" href="/2024/cpp-primer/image-20240705005432263.png"><img src="/images/loading.svg" data-src="/2024/cpp-primer/image-20240705005432263.png" class="" title="image-20240705005432263" lazyload=""></a>
<p>迭代器相减所得的类型是 <strong>difference_type</strong>
是一个带符号的整形数, 可正可负. string 和 vector 都定义了
difference_type.</p>
<h2 id="数组">3.5 数组</h2>
<h3 id="定义和初始化内置数组">3.5.1 定义和初始化内置数组</h3>
<p>数组的大小必须是常量表达式, 也可以留空, 编译器自行推测.
显示初始化时候, 没有提供的位置会被初始化成默认值. 对于字符数组,
可以用字符串字面值进行初始化.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1 = <span class="string">"Cpp"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="不允许拷贝和赋值">不允许拷贝和赋值</h4>
<p>不能用数组为其他数组赋值, 也不能把一个数组拷贝初始化另一个数组.</p>
<h3 id="访问数组元素">3.5.2 访问数组元素</h3>
<h2 id="多维数组">3.6 多维数组</h2>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="top-box-text">第2章 变量和基本类型</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="top-box-text">2.1 基本内置类型</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2convert"><span class="top-box-text">2.1.2 类型转换(convert)</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="top-box-text">2.1.3 字面值常量</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%8F%98%E9%87%8F"><span class="top-box-text">2.2 变量</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="top-box-text">2.2.2 变量声明与定义的关系</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="top-box-text">2.2.3 标识符</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8Bcompound-type"><span class="top-box-text">2.3 复合类型(compound type)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8C%87%E9%92%88"><span class="top-box-text">2.3.2 指针</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="top-box-text">2.3.3 理解复合类型的声明</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="top-box-text">2.4 const 限定符</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#const-%E7%9A%84%E5%BC%95%E7%94%A8"><span class="top-box-text">2.4.1 const 的引用</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E-const"><span class="top-box-text">2.4.2 指针与 const</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%A1%B6%E5%B1%82-const"><span class="top-box-text">2.4.3 顶层 const</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#constexpr-%E4%B8%8E%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="top-box-text">2.4.4 constexpr 与常量表达式</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="top-box-text">2.5 处理类型</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="top-box-text">2.5.1 类型别名</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#auto"><span class="top-box-text">2.5.2 auto</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#decltype-%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6c11"><span class="top-box-text">2.5.3 decltype 类型指示符(C++11)</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="top-box-text">2.6 自定义数据结构</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="top-box-text">预处理器概述</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="top-box-text">第3章 字符串、向量和数组</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84-using-%E5%A3%B0%E6%98%8E"><span class="top-box-text">3.1 命名空间的 using 声明</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-string"><span class="top-box-text">3.2 标准库类型 string</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-string-%E5%AF%B9%E8%B1%A1"><span class="top-box-text">3.2.1 定义和初始化 string 对象</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="top-box-text">3.2.2 string对象上的操作</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%84%E7%90%86-string-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="top-box-text">3.2.3 处理 string 对象中的字符</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-vector"><span class="top-box-text">3.3 标准库类型 vector</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-vector-%E5%AF%B9%E8%B1%A1"><span class="top-box-text">3.3.1 定义和初始化 vector 对象</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%90%91-vector-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="top-box-text">3.3.2 向 vector 对象中添加元素</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%85%B6%E5%AE%83-vector-%E6%93%8D%E4%BD%9C"><span class="top-box-text">3.3.3 其它 vector 操作</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="top-box-text">3.4 迭代器介绍</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="top-box-text">3.4.1 使用迭代器</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="top-box-text">3.4.2 迭代器运算</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%95%B0%E7%BB%84"><span class="top-box-text">3.5 数组</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="top-box-text">3.5.1 定义和初始化内置数组</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="top-box-text">3.5.2 访问数组元素</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="top-box-text">3.6 多维数组</span></a></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/DM8/">
          <h3 class="post-title">
            下一篇：图论初步
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/Pro1eta" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>

